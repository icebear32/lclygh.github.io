//整型提升


//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//	为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，
//	这种转换称为整型提升。

//#include <stdio.h>
//
//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011 -- 被截断
//	//00000011 - a  -- 截断后
//
//	char b = 127;
//	//00000000000000000000000001111111 -- 被截断
//	//01111111 - b -- 截断后
//
//	// a 和 b 如何相加？
//	//00000000000000000000000000000011
//	//00000000000000000000000001111111
//	//00000000000000000000000010000010 -- 被截断
//
//	char c = a + b;
//	//10000010 - c -- 截断后
//	//整型提升
//	//11111111111111111111111110000010 - 补码
//	//11111111111111111111111110000001 - 反码
//	//10000000000000000000000001111110 - 原码
//	//-126
//
//	printf("%d\n", c);
//
//	return 0;
//}

//因为char类型被定义了整型值，32个字节，而char类型只能存放8个字节，所以被截断，从小位（右边）开始截断
//整型提升是因为进行运算的数达不到运算要求而进行的操作
//b和c的值被提升为普通整型，然后再执行加法运算。加法运算完成之后，结果将被截断，然后再存储于a中。



//#include <stdio.h>
//
//int main()
//{
//	//负数的整形提升char c1 = -1;
//	//变量c1的二进制位(补码)中只有8个比特位:1111111
//	//因为char 为有符号的char
//	//所以整形提升的时候，高位补充符号位，即为1提升之后的结果是 :
//	//11111111111111111111111111111111
//	
//	//正数的整形提升
//	char c2 = 1;
//	////变量c2的二进制位(补码)中只有8个比特位:00000001
//	//因为char为有符号的char
//	//所以整形提升的时候，高位补充符号位，即为0
//	//提升之后的结果是 :
//	//00000000000000000000000000000001
//	
//	//无符号整形提升，高位补O
//
//
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//
//	return 0;
//}
/*
	例子中的a,b要进行整形提升,但是c不需要整形提升a,b整形提升之后,变成了负数,所以表达式a==0xb6 , b==0xb600的结果是假,
	但是c不发生整形提升,则表达式c==Oxb6000000的结果是真.
	所以程序输出的结果是:c
*/



//#include <stdio.h>
//
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));//1
//	printf("%u\n", sizeof(+c));//4
//	printf("%u\n", sizeof(!c));//1
//
//	return 0;
//}
/*
	例子中的,c只要参与表达式运算,就会发生整形提升,表达式+c ,就会发生提升,所以sizeof(+c)是4个字节.
	表达式-c也会发生整形提升,所以sizeof(-c)是4个字节,但是sizeof(c),就是1个字节.
*/


//#include <stdio.h>
//
//int main()
//{
//	float f = 3.14;
//	int num = f;//隐式转换，会有精度丢失
//	printf("%d", num);
//
//	return 0;
//}