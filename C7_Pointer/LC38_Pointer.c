//笔试题

//#include <stdio.h>
//
//int main()
//{
//	char* p = "abcdef";
//	//数组里的是 a b c d e f \0
//
//	printf("%d\n", strlen(p)); //6
//	//因为p存放的是数组，是一个首元素地址
//	//所以strlen定位到第一个元素开始计算长度，遇到'\0'停止
//	//所以得到6
//
//	printf("%d\n", strlen(p + 1)); //5 
//	//因为p存放的是数组，是一个首元素地址
//	//(p + 1)是跳过一个元素
//	//所以strlen定位到第二个元素开始计算长度，遇到'\0'停止
//	//所以得到 5
//
//	//printf("%d\n", strlen(*p)); //err
//	//*p得到的是“a”，strlen是接收地址参数的
//	//strlen接收到“a”后，a的码值是97
//	//strlen通过97经过计算，属于非法操作
//
//	//printf("%d\n", strlen(p[0])); //err
//	//*p得到的是“a”，strlen是接收地址参数的
//	//strlen接收到“a”后，a的码值是97
//	//strlen通过97经过计算，属于非法操作
//
//	printf("%d\n", strlen(&p)); //随机值
//	//因为p存的是数组首元素的地址
//	//&p就是取p的地址，是一个地址
//	//不可预测地址的值
//	//假设a的地址（p的地址）是 0x0012ff44
//	//又因为系统是小端存储，所以地址是 44 ff 12 00 存放
//	//所以strlen开始计算长度，遇到00的时候结束，所以长度是 3
//	//因为地址不可预测，所以是随机值
//
//	printf("%d\n", strlen(&p + 1)); //随机值
//	//因为(&p + 1)是p地址下一个地址
//	//更不可预知
//	//所以是随机值
//
//	printf("%d\n", strlen(&p[0] + 1)); //5
//	//&p是首元素地址，(&p[0] + 1)是跳过一个首元素地址
//	//所以从第二个元素开始计算
//	//所以是 5
//
//	return 0;
//}