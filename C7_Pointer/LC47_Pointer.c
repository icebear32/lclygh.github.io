//指针笔试题

////8
//#include <stdio.h>
//
//int main()
//{
//	char* c[] = { "ENTER","NEW","POINT","FIRST" };
//	//字符指针数组，数组里面的每个元素的类型是char*
//	// char* -> "ENTER"
//	// char* -> "NEW"
//	// char* -> "POINT"
//	// char* -> "FIRST"
//
//	char** cp[] = { c + 3,c + 2,c + 1,c };
//	// cp数组每个元素的类型char** 类型，存放了四个元素
//	// char** 可以存放 char* 的内容，而c数组的是首元素地址	   
//	// c + 3	指向c数组的第四个元素 -> "FIRST"
//	// c + 2	指向c数组的第三个元素 -> "POINT"
//	// c + 1	指向c数组的第二个元素 -> "NEW"
//	// c		指向c数组的第一个元素 -> "ENTER"
//	// cp的首元素地址指向 c + 3 的地址 -> "FIRST"
//
//	char*** cpp = cp; 
//	// cpp数组每个元素的类型是char*** 类型，是一个指针
//	//指向的是cp的首元素地址 cp的首元素地址指向 c + 3 的地址 -> "FIRST"
//
//	printf("%s\n", **++cpp);
//	// ++cpp 是本来指向 cp数组首元素地址的位置发生改变，跳过一个元素
//	// 所以指向的是 cp数组的第二个元素 c + 2 的地址
//	//
//	// *++cpp 解引用++cpp（c + 2 的地址），得到的是c数组"POINT"的首元素地址（p的地址）
//	//
//	// **++cpp 再次解引用 c数组"POINT"的首元素地址 得到 的是 POINT 的内容
//
//	printf("%s\n", *--*++cpp + 3); 
//	// 因为上一个已经++cpp了，改变cpp指向的地址，指向的是 cp数组的第二个元素 c + 2 的地址
//	//
//	// ++cpp 操作
//	// 所以 ++cpp 再次移动位置跳过一个元素，指向 c + 1的地址（指向c数组的第二个元素 -> "NEW"）
//	//
//	// *++cpp 操作
//	// 对++cpp进行解引用操作，得到的是  c + 1的地址的空间内容
//	//
//	// --*++cpp 操作
//	// 对得到*++cpp 的空间进行--操作，c+1就变成了c
//	// 地址就由原来指向 指向c数组的第二个元素 -> "NEW" 变成了 指向c数组的第一个元素 -> "ENTER" 的地址了
//	//
//	// *--*++cpp 操作
//	// 对 --*++cpp 进行解引用操作，得到的是 c数组的第一个元素地址 的内容 "ENTER"的首元素“E”地址
//	//
//	// *--*++cpp + 3 操作
//	// 得到的是“E”地址向后的三个元素的地址 - “E”的地址
//	// 
//	// 打印的是 “ER”
//
//	/*
//		注:	int a = 10
//			++a;//a == 11
//			++a;//a == 12
//			++操作已经发生改变了，不再回去
//	*/
//	
//	printf("%s\n", *cpp[-2] + 3); 
//	// 因为上一个已经++cpp了，改变cpp指向的地址，指向的是 cp数组的第二个元素 c + 1 的地址
//	//
//	// cpp[-2]操作
//	// cpp[-2] 等价于 *(cpp +(-2)) 得到一个地址，然后解引用
//	// *(cpp-2) 的cpp-2产生的地址是指向c+3的地址，向前移动两个元素
//	// 解引用拿到 c+3的地址 的内容
//	// 注意：cpp-2之后的cpp不会发生改变，还是指向原来的地址
//	//
//	// *cpp[-2]操作
//	// *cpp[-2] 等价于 *(*(cpp-2)) 
//	// *(cpp-2) 拿到 c+3的地址 的内容 ，是存放 "FIRST" 首元素的地址
//	// *(*(cpp-2)) 解引用 得到 "FIRST" 首元素的地址 的“F” 的地址
//	//
//	// *cpp[-2] + 3 操作
//	// 首元素的地址 的“F” 的地址跳过三个元素得到 "R" 后的地址
//	// 往后打印“ST”
//
//	printf("%s\n", cpp[-1][-1] + 1);
//	// 因为上一次进行的运算 cpp指向的地址没有发生变化，所以cpp还是指向 cp数组的第二个元素 c + 1 的地址
//	// 
//	// cpp[-1][-1] 相当于 * ( * (cpp - 1) -1)
//	// cpp[-1][-1]
//	// * ( * (cpp - 1) -1)
//	// 
//	// * (cpp - 1)
//	// 指向的是 c+1 地址，所以进行 cpp-1 操作，数组跳回一个元素，
//	// 指向的地址的移动到c+2，解引用得到c+2的地址的内容"POINT"，存放c数组的char*元素
//	// 
//	// * ( * (cpp - 1) -1)
//	// * (cpp - 1) 得到c+2的地址的内容"POINT"的首地址，存放c数组的char*元素
//	// 进行 * (cpp - 1) -1 操作，指向的地址移动到“NEW”的首元素地址的内容
//	//
//	// cpp[-1][-1] + 1 操作
//	// 将 cpp[-1][-1] 得到的是“NEW”的首元素地址“E”
//	// cpp[-1][-1]+1 操作是从 E 向后走一个元素位置，
//	// %s 打印E后字符，打印输出“EW” 
//
//	return 0;
//}